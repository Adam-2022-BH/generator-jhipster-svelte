<script>
	import {afterUpdate, createEventDispatcher} from 'svelte'
	import {faExclamationCircle} from '@fortawesome/free-solid-svg-icons/faExclamationCircle.js'
	import {faCaretDown} from '@fortawesome/free-solid-svg-icons/faCaretDown.js'

	import Icon from '$lib/Icon.svelte'
	import CheckboxControl from '$lib/CheckboxControl.svelte'

	export let name = ''
	export let value = []
	export let label = ''
	export let options = []
	export let validations = []
	export let multiple = false

	const dispatch = createEventDispatcher()
	const randomSuffix = Date.now()

	let focused = false
	let isOpen = false
	let displayName = []

	let dirty = false
	let valid = false
	let message
	let selectOptions

	$: normalizedValue = value && value.length ? (
		options && options.length
			? value.map(value => {
				Object.keys(value).forEach(key => {
					if (!Object.keys(options[0]['value']).includes(key)) {
						delete value[key]
					}
				})
				return value
			})
			: []
	) : []
	$: displayName = value && value.length ? (
		options && options.length
			? options[0]['key'] ? value.map(value => value[options[0]['key']]) : value
			: []
	) : []
	$: focusedOrContainsValue = (normalizedValue && normalizedValue.length !== 0) || focused
	$: pristine = !focused && !dirty
	$: pristineOrValid = pristine || valid
	$: focusedAndValidOrPristine = focused && (!dirty || valid)
	$: dirtyAndInvalid = dirty && !valid
	$: isRequired =
		validations.find(validation => validation.type === 'required') !==
		undefined

	function selectOption(event) {
		dirty = true
		const eventValue = typeof options[0]['value'] === 'object' ? JSON.parse(event.target.value) : event.target.value;
		if (event.target.checked) {
			if (multiple) {
				value = [...value, eventValue]
			} else {
				value = [ eventValue ]
			}
		} else {
			if (multiple) {
				value = value.filter(val => val !== eventValue)
			} else {
				value = []
			}
		}

		validateRequired()
		const valueToDispatch = multiple
			? value
			: value.length > 0
				? value[0]
				: null
		dispatch('select', {
			value: valueToDispatch,
		})
	}

	afterUpdate(() => validateRequired())

	function validateRequired() {
		if (isRequired && (normalizedValue && !normalizedValue.length)) {
			valid = false
			message = validations.find(
				validation => validation.type === 'required'
			).message
		} else {
			valid = true
		}
		dispatch('validate', { valid, message })
	}

	function toggleOptions() {
		isOpen = !isOpen
	}

	function navigateToFirstOption(event) {
		switch(event.keyCode) {
			case 40:
				if (!isOpen) {
					isOpen = true
				}
				if (selectOptions.firstChild) {
					selectOptions.firstChild.querySelector('input').focus()
				} else {
					isOpen = false
				}
				break;
			case 27:
			case 9:
				isOpen = false
				break;
		}
	}

	function navigateOptions(event) {
		const parent = event.target.closest('div')
		switch(event.keyCode) {
			case 38:
				if (parent.previousSibling) {
					parent.previousSibling.querySelector('input').focus()
				} else {
					isOpen = false
				}
				break;
			case 40:
				if (parent.nextSibling) {
					parent.nextSibling.querySelector('input').focus()
				} else {
					isOpen = false
				}
				break;
			case 32:
			case 13:
				event.target.click()
				break;
			case 27:
			case 9:
				isOpen = false
				break;
		}
	}
</script>

<div class="mt-4 relative h-12">
	<label
		class="absolute left-0 px-1 ml-2 z-10 transition-all duration-200 rounded pointer-events-none"
		class:z-30="{isOpen}"
		class:-mt-2="{focusedOrContainsValue || isOpen}"
		class:bg-white="{focusedOrContainsValue || isOpen}"
		class:dark:bg-gray-800="{focusedOrContainsValue || isOpen}"
		class:top-0="{focusedOrContainsValue || isOpen}"
		class:pt-3="{!focusedOrContainsValue && !isOpen}"
		class:pt-0="{focusedOrContainsValue || isOpen}"
		class:text-xs="{focusedOrContainsValue || isOpen}"
		class:text-gray-700="{!focused}"
		class:dark:text-gray-200="{!focused}"
		class:text-primary-700="{focusedAndValidOrPristine}"
		class:dark:text-primary-500="{focusedAndValidOrPristine}"
		class:text-red-600="{dirtyAndInvalid && (focused || isOpen)}"
		class:dark:text-red-500="{dirtyAndInvalid && (focused || isOpen)}"
		for="{name + randomSuffix}"
	>{label}<span class="ml-px">{isRequired ? '*' : ''}</span>
	</label>
	<div
		class="w-full relative flex flex-row justify-center items-center rounded bg-white dark:bg-gray-800"
		class:border="{!focused && !isOpen}"
		class:border-2="{focused || isOpen}"
		class:border-gray-400="{pristineOrValid}"
		class:dark:border-gray-700="{pristineOrValid}"
		class:border-primary-600="{focusedAndValidOrPristine ||
			(isOpen && !dirtyAndInvalid)}"
		class:dark:border-primary-500="{focusedAndValidOrPristine ||
			(isOpen && !dirtyAndInvalid)}"
		class:border-red-600="{dirtyAndInvalid}"
		class:dark:border-red-500="{dirtyAndInvalid}"
		class:z-20="{isOpen}"
		class:rounded-bl-none="{isOpen}"
		class:rounded-br-none="{isOpen}"
	>
		<input
			class="px-3 py-3 w-full shadow-none dark:bg-gray-800 outline-none focus:ring-0 overflow-ellipsis whitespace-nowrap overflow-hidden rounded"
			class:z-20="{isOpen}"
			type="text"
			name="{name}"
			readonly
			id="{name + randomSuffix}"
			value="{displayName && displayName.length ? displayName.join(', ') : null}"
			autocomplete="off"
			on:input="{() => toggleOptions()}"
			on:keydown="{(event) => navigateToFirstOption(event)}"
			on:focus="{() => ((focused = true), (toggleOptions()))}"
			on:blur="{() => (focused = false)}"
			{...$$restProps}
		/>
		<button
			type="button"
			aria-label="Expand select options"
			tabindex="-1"
			class:z-20="{isOpen}"
			class="focus:outline-none focus:ring-0"
			on:keydown="{(event) => navigateToFirstOption(event)}"
			on:click|preventDefault="{() => toggleOptions()}"
		>
			<Icon
				classes="{isOpen ? 'opacity-100' : 'opacity-70'}"
				icon="{faCaretDown}"
			/>
		</button>
	</div>
	{#if isOpen}
		<button
			data-test="{name}-bg"
			tabindex="-1"
			on:click|preventDefault="{() => (isOpen = false)}"
			class="fixed block inset-0 w-full h-full z-10 bg-gray-200 dark:bg-gray-700 opacity-50 cursor-default"
		></button>
	{/if}
	<div
		bind:this={selectOptions}
		on:keydown|preventDefault="{(event) => navigateOptions(event)}"
		data-test="{name}-options"
		class:hidden="{!isOpen}"
		class="absolute left-0 w-full py-2 bg-white dark:bg-gray-800 border-b-2 rounded shadow-md border-2 z-10 border-t-0 rounded-tl-none rounded-tr-none"
		class:border-primary-600="{focusedAndValidOrPristine ||
			!dirtyAndInvalid}"
		class:border-red-600="{dirtyAndInvalid}"
	>
		{#each options as option (option.name)}
			<div
				class="block px-3 py-1 rounded-none font-normal hover:text-white dark:hover:text-gray-800 text-gray-800 dark:text-gray-200 hover:bg-primary-600 dark:hover:bg-primary-500"
			>
				<CheckboxControl
					tabindex="-1"
					checked="{normalizedValue && (typeof option.value === 'object' ? JSON.stringify(normalizedValue).includes(JSON.stringify(option.value)) : normalizedValue.includes(option.value))}"
					value="{typeof option.value === 'object' ? JSON.stringify(option.value) : option.value}"
					on:change="{event => selectOption(event)}"
				>{option.name}</CheckboxControl
				>
			</div>
		{/each}
	</div>
</div>
<div class="flex flex-col mt-1 pr-3 text-xs text-red-600 dark:text-red-500">
	<slot message="{message}" dirty="{dirty}" valid="{valid}">
		{#if dirty && !valid}
			<div data-test="{name}-error" class="flex items-center">
				<Icon classes="mr-2" icon="{faExclamationCircle}" />
				{message}
			</div>
		{:else}&nbsp;{/if}
	</slot>
</div>
